"""Audio processing module for handling audio file operations."""

from pathlib import Path
from typing import Optional, Dict, Union

import whisper
from pydub import AudioSegment
from media_analyzer.core.exceptions import AudioProcessingError, ValidationError


class AudioProcessor:
    """Handles audio file processing and speech recognition."""

    SUPPORTED_FORMATS = {"wav", "mp3"}

    def __init__(self, config: Optional[Dict] = None):
        """Initialize the audio processor with optional configuration."""
        self.config = config or {}
        self.model = whisper.load_model("tiny")  # Use tiny model for fast testing

    def validate_file(self, file_path: Union[str, Path]) -> Path:
        """
        Validate that the file exists and has a supported format.
        
        Args:
            file_path: Path to the audio file
            
        Returns:
            Path object of the validated file
            
        Raises:
            FileNotFoundError: If file doesn't exist
            ValueError: If file format is not supported
        """
        path = Path(file_path)
        if not path.exists():
            raise FileNotFoundError(f"Audio file not found: {path}")
            
        suffix = path.suffix[1:].lower() if path.suffix else ""
        if suffix not in self.SUPPORTED_FORMATS:
            raise ValueError(f"Unsupported audio format: {path.suffix}")
            
        return path

    def load_audio(self, file_path: Path) -> AudioSegment:
        """
        Load an audio file into memory.
        
        Args:
            file_path: Path to the audio file
            
        Returns:
            AudioSegment object containing the audio data
            
        Raises:
            AudioProcessingError: If the file cannot be loaded
        """
        try:
            return AudioSegment.from_file(str(file_path))
        except Exception as e:
            raise AudioProcessingError(f"Failed to load audio file: {e}")

    def extract_text(self, audio_data: AudioSegment, options: Optional[Dict] = None) -> Dict:
        """
        Extract text from audio data using speech recognition.
        
        Args:
            audio_data: AudioSegment containing the audio
            options: Optional parameters for recognition
            
        Returns:
            Dictionary containing:
                - text: The transcribed text
                - confidence: Confidence score (0-1)
                - metadata: Additional recognition metadata
                
        Raises:
            AudioProcessingError: If text extraction fails
        """
        options = options or {}
        temp_wav = Path("temp.wav")
        
        try:
            # Export to WAV for speech recognition
            audio_data.export(str(temp_wav), format="wav")
            
            # Use Whisper for transcription
            result = self.model.transcribe(
                str(temp_wav),
                language=options.get("language", "en"),
                fp16=False
            )
            
            response = {
                "text": result["text"],
                "confidence": 0.9,  # Whisper typically has good accuracy
                "metadata": {
                    "duration": len(audio_data) / 1000.0,  # Convert to seconds
                    "language": options.get("language", "en"),
                    "segments": []
                }
            }
            return response
            
        except Exception as e:
            raise AudioProcessingError(f"Failed to extract text: {e}")
        finally:
            temp_wav.unlink(missing_ok=True)

    def get_audio_info(self, audio_data: AudioSegment) -> Dict:
        """
        Get audio file metadata.
        
        Args:
            audio_data: AudioSegment containing the audio
            
        Returns:
            Dictionary containing audio metadata
        """
        return {
            "sample_rate": audio_data.frame_rate,
            "channels": audio_data.channels,
            "duration": len(audio_data) / 1000.0  # Convert to seconds
        }
